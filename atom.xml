<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-07T06:39:56.125Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mireyazzz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java学习笔记-多线程</title>
    <link href="http://yoursite.com/2018/10/24/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/10/24/java学习笔记-多线程/</id>
    <published>2018-10-24T07:30:49.000Z</published>
    <updated>2018-11-07T06:39:56.125Z</updated>
    
    <content type="html"><![CDATA[<p>目录：<br>一、创建及启动线程<br>二、线程状态切换<br>三、线程安全（volatile，reentrantLock，syncrhoized）<br>四、线程池<br>五、concurrent 包</p><h2 id="一、创建及启动线程"><a href="#一、创建及启动线程" class="headerlink" title="一、创建及启动线程"></a>一、创建及启动线程</h2><p>###1. 实现Runnable接口<br>1.定义Runnable接口的实现类，一样要重写run()方法，这个run（）方法和Thread中的run()方法一样是线程的执行体<br>2.创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象<br>3.通过调用线程对象的start()方法来启动线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public  class Runner1 implements Runnable &#123;</span><br><span class="line">     public void run()&#123;</span><br><span class="line">       for(int i=0;i&lt;100;i++)  &#123;</span><br><span class="line">           System.out.println(&quot;runner1: &quot; +i);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">    Runner1 r1 = new Runner1();</span><br><span class="line">    //r1.run();此处视为方法调用，等run方法执行完毕后才进行main（）方法操作。</span><br><span class="line">    Thread t = new Thread(r1);</span><br><span class="line">    t.start();</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        System.out.println(&quot;main thread：&quot; + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时新线程和主线程交替打印。</p><h3 id="2-继承thread类"><a href="#2-继承thread类" class="headerlink" title="2. 继承thread类"></a>2. 继承thread类</h3><p>1.定义Thread类的子类，并重写该类的run()方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。<br>2.创建Thread子类的实例，也就是创建了线程对象<br>3.调用线程的start()方法启动线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Runner2 extends Thread &#123;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for(int i=0;i&lt;100;i++)  &#123;</span><br><span class="line">            System.out.println(&quot;runner2: &quot; +i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[] )&#123;</span><br><span class="line"></span><br><span class="line">     Runner2 r2=new Runner2();</span><br><span class="line">     r2.start();</span><br><span class="line">     </span><br><span class="line">     for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">         System.out.println(&quot;main thread：&quot; + i);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-实现callable接口"><a href="#3-实现callable接口" class="headerlink" title="3. 实现callable接口"></a>3. 实现callable接口</h3><p>1.创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。<br>2.使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值<br>3.使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）<br>4.调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        Runner3 td = new Runner3();</span><br><span class="line">        FutureTask&lt;Integer&gt; result = new FutureTask&lt;&gt;(td);</span><br><span class="line">        new Thread(result).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Integer sum = result.get();  </span><br><span class="line">//FutureTask 可用于 闭锁 类似于CountDownLatch的作用，在所有的线程没有执行完成之后这里是不会执行的</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">            System.out.println(&quot;------------------------------------&quot;);</span><br><span class="line">        &#125; catch (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Runner3 implements Callable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt;= 100000; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、线程状态切换"><a href="#二、线程状态切换" class="headerlink" title="二、线程状态切换"></a>二、线程状态切换</h2><p><img src="https://upload-images.jianshu.io/upload_images/1689841-383f7101e6588094.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p><p>###1. sleep()<br>sleep()方法需要指定等待的时间,它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态。可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是sleep()方法不会释放“锁标志”，也就是说如果有synchronized同步块，其他线程仍然不能访问共享数据。</p><p>###2.yield()<br>　yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也和sleep()方法不同。</p><p>###3.join()<br>join()方法会使当前线程等待调用join()方法的线程结束后才能继续执行.</p><p>###4.notify()&amp;notifyALL()<br>先说两个概念：锁池和等待池<br>  ● 锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。<br>  ● 等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中。<br>然后再来说notify和notifyAll的区别：<br>  ● 如果线程调用了对象的wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。<br>  ● 当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。<br>综上，所谓唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而notify只会唤醒一个线程。有了这些理论基础，后面的notify可能会导致死锁，而notifyAll则不会的例子也就好解释了。</p><p>##三、线程安全（volatile，reentrantLock，syncrhoized）</p><p>##四、线程池</p><p>##五、concurrent 包</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目录：&lt;br&gt;一、创建及启动线程&lt;br&gt;二、线程状态切换&lt;br&gt;三、线程安全（volatile，reentrantLock，syncrhoized）&lt;br&gt;四、线程池&lt;br&gt;五、concurrent 包&lt;/p&gt;
&lt;h2 id=&quot;一、创建及启动线程&quot;&gt;&lt;a href=&quot;#一、
      
    
    </summary>
    
    
      <category term="synchronized" scheme="http://yoursite.com/tags/synchronized/"/>
    
      <category term="同步" scheme="http://yoursite.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
      <category term="多线程，并发" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>jvm学习笔记-原理篇</title>
    <link href="http://yoursite.com/2018/10/24/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8E%9F%E7%90%86%E7%AF%87/"/>
    <id>http://yoursite.com/2018/10/24/jvm学习笔记-原理篇/</id>
    <published>2018-10-24T07:28:19.000Z</published>
    <updated>2018-10-29T07:23:28.482Z</updated>
    
    <content type="html"><![CDATA[<p>目录：<br>  一、JVM内存模型和结构<br>  二、Java 类加载机制<br>  三、方法执行过程<br>  四、java大版本新特性</p><p>##一、jvm内存结构<br><img src="https://img.alicdn.com/tfs/TB1bhRnRFXXXXa2XVXXXXXXXXXX-510-401.png" alt=""></p><p>###heap堆<br>堆是内存管理里最大的一块，是线程共享的数据。在jvm启动时创建。<br>目的是存放对象实例。java的引用传递依靠的就是堆内存，例如引用类型的变量是在栈区保存一个指向堆区的指针，通过这个指针可以找到实例在堆区对应的对象。同一块堆内存可以被不同的栈内存所指向。<br>堆内部细分为新生代和老年代，新生代又分为Eden，From survior，TO survior，hotspot虚拟机中默认比例是8:1:1<br><img src="https://img.alicdn.com/tfs/TB1EVhqRFXXXXcFXFXXXXXXXXXX-583-183.png" alt=""></p><p>###方法区<br>方法区又称为永久区，线程共享，目的是存放已被jvm加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，垃圾回收在这个区域比较少，主要目的是对常量池的回收和类的卸载。</p><p>####运行时常量池<br>运行时常量池是方法区的一部分，用于存储编译器产生的字面量和符号引用，这类内容类加载后被存储到方法区的rcp。</p><p>###JVM Stack<br>JVM栈是线程私有的，它的生命周期与线程相同。JVM栈描述的是java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。<br>局部变量表中存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象的引用类型（reference类型，不等同于对象本身，根据不同的虚拟机实现，可能是一个指向对象起始地址的引用指针，也可能是一个代表对象的句柄或者其他与对象相关的位置）。局部变量表中需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。<br><img src="https://images0.cnblogs.com/blog/610052/201409/131449151064177.png" alt=""></p><p>###本地方法栈<br>与VM Strack相似，VM Strack为JVM提供执行JAVA方法的服务，Native Method Stack则为JVM提供使用native 方法的服务。</p><p>###程序计数器<br>程序计数器是一块较小的内存区域，作用可以看做是当前线程执行的字节码的位置指示器。分支、循环、跳转、异常处理和线程恢复等基础功能都需要依赖这个计算器来完成</p><p>##二、Java 类加载机制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">加载</span><br><span class="line">⬇️</span><br><span class="line">验证➡️准备➡️解析</span><br><span class="line">           ⬇️</span><br><span class="line">           初始化</span><br><span class="line">           ⬇️</span><br><span class="line">           使用</span><br><span class="line">           ⬇️</span><br><span class="line">           卸载</span><br></pre></td></tr></table></figure></p><p>类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。</p><ol><li>隐式加载<br>程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中</li><li>显式加载<br>通过class.forname()等方法，显式加载需要的类</li></ol><p>1、通过一个类的全限定名来获取其定义的二进制字节流。<br>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>jvm通过类加载器把数据加载到内存</p><p>####1.启动类加载器Bootstrp loader<br>Bootstrp加载器是用C++语言写的，它是在Java虚拟机启动后初始化的，它主要负责加载%JAVA_HOME%/jre/lib,-Xbootclasspath参数指定的路径以及%JAVA_HOME%/jre/classes中的类。</p><p>####2.扩展类加载器ExtClassLoader<br>Bootstrp loader加载ExtClassLoader,并且将ExtClassLoader的父加载器设置为Bootstrp loader。<br>主要加载%JAVA_HOME%/jre/lib/ext，此路径下的所有classes目录以及java.ext.dirs系统变量指定的路径中类库。</p><p>####3.应用程序类加载器AppClassLoader<br>Bootstrp loader加载完ExtClassLoader后，就会加载AppClassLoader,并且将AppClassLoader的父加载器指定为 ExtClassLoader。<br>ClassLoader中有个getSystemClassLoader方法,此方法返回的正是AppclassLoader.AppClassLoader主要负责加载classpath所指定的位置的类或者是jar文档，它也是Java程序默认的类加载器。</p><p>####示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class JVMTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassLoader  loader = JVMTest.class.getClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        ClassLoader loderp =loader.getParent();</span><br><span class="line">        System.out.println(loderp);</span><br><span class="line">        ClassLoader loaderpp =loderp.getParent();</span><br><span class="line">        System.out.println(loaderpp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@135fbaa4</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@2503dbd3</span><br><span class="line">null</span><br></pre></td></tr></table></figure></p><p>由于Bootstrap Loader是用C++语言写的，并不存在类实体，所以打印为null。</p><p>####类加载模型：双亲委派<br>这个模型要求除了Bootstrap ClassLoader外，其余的类加载器都要有自己的父加载器。子加载器通过组合来复用父加载器的代码，而不是使用继承。在某个类加载器加载class文件时，它首先委托父加载器去加载这个类，依次传递到顶层类加载器(Bootstrap)。如果顶层加载不了（它的搜索范围中找不到此类），子加载器才会尝试加载这个类。</p><p>#####双亲委派模型解决的问题：</p><ul><li>每一个类都只会被加载一次，避免了重复加载</li><li>每一个类都会被尽可能的加载（从引导类加载器往下，每个加载器都可能会根据优先次序尝试加载它）</li><li>有效避免了某些恶意类的加载（比如自定义了Java。lang.Object类，一般而言在双亲委派模型下会加载系统的Object类而不是自定义的Object类）</li></ul><p>##三、方法执行过程</p><p>##四、java大版本新特性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目录：&lt;br&gt;  一、JVM内存模型和结构&lt;br&gt;  二、Java 类加载机制&lt;br&gt;  三、方法执行过程&lt;br&gt;  四、java大版本新特性&lt;/p&gt;
&lt;p&gt;##一、jvm内存结构&lt;br&gt;&lt;img src=&quot;https://img.alicdn.com/tfs/TB1bhR
      
    
    </summary>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
      <category term="类加载" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-栈</title>
    <link href="http://yoursite.com/2018/10/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <id>http://yoursite.com/2018/10/12/数据结构-栈/</id>
    <published>2018-10-12T08:42:18.000Z</published>
    <updated>2018-10-12T08:44:11.109Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记-synchronized</title>
    <link href="http://yoursite.com/2018/10/07/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-synchronized/"/>
    <id>http://yoursite.com/2018/10/07/java学习笔记-synchronized/</id>
    <published>2018-10-07T06:28:48.000Z</published>
    <updated>2018-10-29T10:27:02.982Z</updated>
    
    <content type="html"><![CDATA[<p>杨晓峰老师《java核心技术36讲》15，16课&amp;郑雨迪老师《深入拆解java虚拟机》14课学习总结</p><p>参考文章：<a href="https://www.cnblogs.com/charlesblc/p/5994162.html" target="_blank" rel="noopener">https://www.cnblogs.com/charlesblc/p/5994162.html</a></p><h2 id="synchronized的实现原理"><a href="#synchronized的实现原理" class="headerlink" title="synchronized的实现原理"></a>synchronized的实现原理</h2><p>在java程序中，我们利用synchronized关键字来对程序进行加锁，它可以申明一个synchronized代码块，也可以标记静态方法或者实例方法。</p><h3 id="1-声明synchronized-代码块"><a href="#1-声明synchronized-代码块" class="headerlink" title="1.声明synchronized 代码块"></a>1.声明synchronized 代码块</h3><p>是由一对 monitorenter/monitorexit指令实现的，monitor 对象是同步的基本实现单元。</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void foo(Object lock) &#123;</span><br><span class="line">  synchronized (lock) &#123;</span><br><span class="line">    lock.hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码编译的字节码会包括一个monitorenter指令和多个monitorexit，jvm需要确保所获得的锁在正常/异常执行路径都能够被解锁。</p><p>执行monitorenter时</p><ul><li>如果目标锁的计数器为0，说明他没有被其他线程所持有，jvm会将锁对象的持有线程设置为当前线程，并将计数器加1.</li><li>如果目标锁的计数器不为0，如果锁对象的持有线程是当前线程，jvm可以将计数器加1，否则等待，直到持有线程释放该锁。</li></ul><p>执行monitorexit时，jvm将锁对象的计数器减1，如果计数器为0，代表锁已经被释放。</p><h3 id="2-用synchronized标记方法"><a href="#2-用synchronized标记方法" class="headerlink" title="2.用synchronized标记方法"></a>2.用synchronized标记方法</h3><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void foo(Object lock) &#123;</span><br><span class="line">  lock.hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码编译的字节码中方法的访问有ACC_SYNCHRONIZED。但是没有monitorenter或者monitorexit。</p><p>因为方法级别的同步是隐式的，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构（method_info structure）中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否是同步方法。</p><p>当调用方法时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否设置，如果设置了，执行线程先持有同步锁，然后执行方法，最后在方法完成时释放锁。</p><h2 id="锁的升级降级"><a href="#锁的升级降级" class="headerlink" title="锁的升级降级"></a>锁的升级降级</h2><ul><li>jvm 提供三种不同的Monitor实现，即偏斜锁，轻量锁，重量锁。</li><li>当jvm检测到不同的竞争状况时，会自动切换到适合的锁实现，这就是锁的升级降级。</li><li>当没有竞争出现时，默认使用偏斜锁。</li></ul><p><img src="https://wiki.openjdk.java.net/download/attachments/11829266/Synchronization.gif?version=4&amp;modificationDate=1208918680000&amp;api=v2" alt="image"><br>其中，00代表轻量锁，01代表无锁（或者偏向锁），10代表重量锁，11则根垃圾回收算法的标记有关。</p><p>在所有的锁都启用的情况下线程进入临界区时会先去获取偏向锁，如果已经存在偏向锁了，则会尝试获取轻量级锁，如果以上两种都失败，则启用自旋锁，如果自旋也没有获取到锁，则使用重量级锁，没有获取到锁的线程阻塞挂起，直到持有锁的线程执行完同步块唤醒他们；</p><h3 id="重量锁"><a href="#重量锁" class="headerlink" title="重量锁"></a>重量锁</h3><p>重量锁会阻碍加锁失败的线程，并在目标锁被释放时唤醒这些线程。<br>为了避免昂贵的线程阻塞，唤醒的过程，jvm会在线程进入阻塞状态之前，以及被唤醒后竞争不到锁的情况下，进入自旋状态，在处理器上空跑并轮询锁是否释放，如果此时锁恰好被释放了，那线程便无须进入阻塞状态，直接获得这把锁。</p><h3 id="轻量锁"><a href="#轻量锁" class="headerlink" title="轻量锁"></a>轻量锁</h3><p>轻量级锁是相对于重量级锁而言在获取锁和释放锁时更加高效，但轻量级锁并不能代替重量级锁。轻量级锁适用的场景是在线程交替获取某个锁执行同步代码块的场景，如果出现多个进程同时竞争同一个锁时，轻量级锁会膨胀成重量级锁。</p><p>轻量锁采用CAS操作，把锁对象的标记字段替换成一个指针，指向当前线程栈上的一块空间，存储这锁对象原本的标记字段。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p> 偏向锁只会在第一次请求是采用CAS操作，在锁对象的标记字段中记录下当前线程的地址，在之后的运行过程中，持有该偏向锁的线程的加锁操作将直接返回。</p><table><thead><tr><th>锁</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>重量锁</td><td>多个线程同时进入临界区</td><td>线程竞争不使用自旋不消耗cpu，吞吐量高</td><td>线程阻塞，响应缓慢</td></tr><tr><td>轻量锁</td><td>多个线程交替进入临界区</td><td>竞争的线程不会阻塞，响应速度快</td><td>如果始终得不到锁竞争的线程使用自旋会消耗cpu</td></tr><tr><td>偏向锁</td><td>仅有一个线程进入临界区</td><td>加锁和解锁不需要额外的消耗</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td></tr></tbody></table><h2 id="ReentrantLock和synchronized的区别"><a href="#ReentrantLock和synchronized的区别" class="headerlink" title="ReentrantLock和synchronized的区别"></a>ReentrantLock和synchronized的区别</h2><p>1.用法比较</p><ul><li>Lock使用起来比较灵活，但是必须有释放锁的配合动作</li><li>Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁</li><li>Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等</li></ul><p>2.特性比较</p><p>ReentrantLock的优势体现在：</p><ul><li>具备尝试非阻塞地获取锁的特性：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁</li><li>能被中断地获取锁的特性：与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</li><li>超时获取锁的特性：在指定的时间范围内获取锁；如果截止时间到了仍然无法获取锁，则返回</li></ul><p>3.注意事项</p><p>在使用ReentrantLock类的时，一定要注意三点：</p><ul><li>在finally中释放锁，目的是保证在获取锁之后，最终能够被释放</li><li>不要将获取锁的过程写在try块内，因为如果在获取锁时发生了异常，异常抛出的同时，也会导致锁无故被释放。</li><li>ReentrantLock提供了一个newCondition的方法，以便用户在同一锁的情况下可以根据不同的情况执行等待或唤醒的动作。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;杨晓峰老师《java核心技术36讲》15，16课&amp;amp;郑雨迪老师《深入拆解java虚拟机》14课学习总结&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://www.cnblogs.com/charlesblc/p/5994162.html&quot; target=&quot;_b
      
    
    </summary>
    
    
      <category term="synchronized" scheme="http://yoursite.com/tags/synchronized/"/>
    
      <category term="同步" scheme="http://yoursite.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-链表</title>
    <link href="http://yoursite.com/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/10/06/数据结构-链表/</id>
    <published>2018-10-06T11:10:17.000Z</published>
    <updated>2018-10-12T08:39:30.345Z</updated>
    
    <content type="html"><![CDATA[<p>  王争老师的《数据结构与算法之美》06-07课 链表学习总结 </p><h2 id="一、什么是链表？"><a href="#一、什么是链表？" class="headerlink" title="一、什么是链表？"></a>一、什么是链表？</h2><ol><li>和数组一样，链表也是一种线性表。</li><li>从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。</li><li>链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。</li></ol><h2 id="二、链表的特点"><a href="#二、链表的特点" class="headerlink" title="二、链表的特点"></a>二、链表的特点</h2><ol><li>插入、删除数据效率高O(1)级别（只需更改指针指向即可），随机访问效率低O(n)级别（需要从链头至链尾进行遍历）。</li><li>和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。</li></ol><h2 id="三、常用链表：单链表、循环链表和双向链表"><a href="#三、常用链表：单链表、循环链表和双向链表" class="headerlink" title="三、常用链表：单链表、循环链表和双向链表"></a>三、常用链表：单链表、循环链表和双向链表</h2><h3 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1. 单链表"></a>1. 单链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private class Node &#123;</span><br><span class="line">    private Object data;        //数据</span><br><span class="line">    private Node next = null;  //指针域</span><br><span class="line"></span><br><span class="line">    public Node() &#123;                         //无参数构造函数为了创建头结点服务</span><br><span class="line">        data = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node(E data) &#123;                //带数据的构造函数</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    private Node head;               //头引用（指针）</span><br><span class="line">    private Node tail;                //尾引用（指针）</span><br><span class="line">    private Node point;              //临时引用（指针）</span><br><span class="line">    private int length;                 </span><br><span class="line">    //链表长度</span><br><span class="line"></span><br><span class="line">    public nodeList() &#123;                  //链表构造函数，创建无数据的头结点</span><br><span class="line">        head = new Node();</span><br><span class="line">        tail = head;</span><br><span class="line">        length = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><p><img src="http://oyfmp3adh.bkt.clouddn.com/%E6%9C%AA%E5%91%BD%E5%90%8D1520232582.png" alt="image"></p><p>让p的后继结点改成s的后继结点，再把结点s变成p的后继结点</p><p><code>s-&gt;next=p-&gt;next; p-&gt;next=s;</code><br>具体实现如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void insert(int position, E elem) &#123;</span><br><span class="line">    if (position &gt;= 0 &amp;&amp; position &lt;= length) &#123;</span><br><span class="line">        point = movePoint(position);</span><br><span class="line">        Node tmp = new Node(elem);</span><br><span class="line">        tmp.next = point.next;</span><br><span class="line">        point.next = tmp;</span><br><span class="line">        length++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        System.out.println(&quot;没有指定位置，插入失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>每个节点只包含一个指针，即后继指针。</li><li>单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。</li><li>性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)。<h3 id="2-循环链表"><a href="#2-循环链表" class="headerlink" title="2. 循环链表"></a>2. 循环链表</h3><img src="https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg" alt="image"></li><li>除了尾节点的后继指针指向首节点的地址外均与单链表一致。</li><li>适用于存储有循环特点的数据，比如约瑟夫问题。<h3 id="3-双向链表"><a href="#3-双向链表" class="headerlink" title="3.双向链表"></a>3.双向链表</h3><img src="https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg" alt="image"></li><li>节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。</li><li>首节点的前驱指针prev和尾节点的后继指针均指向空地址。</li><li>性能特点：和单链表相比，存储相同的数据，需要消耗更多的存储空间。</li></ul><p>插入、删除操作比单链表效率更高O(1)级别。以删除操作为例，删除操作分为2种情况：</p><ol><li>给定数据值删除对应节点。</li><li>给定节点地址删除节点。</li></ol><p>对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。</p><p>对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p-&gt;next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。<br>对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p><h3 id="4-双向循环链表"><a href="#4-双向循环链表" class="headerlink" title="4.双向循环链表"></a>4.双向循环链表</h3><p><img src="https://static001.geekbang.org/resource/image/d1/91/d1665043b283ecdf79b157cfc9e5ed91.jpg" alt="image"><br>首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。</p><h2 id="四、选择数组还是链表？"><a href="#四、选择数组还是链表？" class="headerlink" title="四、选择数组还是链表？"></a>四、选择数组还是链表？</h2><h3 id="1-插入、删除和随机访问的时间复杂度"><a href="#1-插入、删除和随机访问的时间复杂度" class="headerlink" title="1. 插入、删除和随机访问的时间复杂度"></a>1. 插入、删除和随机访问的时间复杂度</h3><p>数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。</p><p>链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。</p><h3 id="2-数组缺点"><a href="#2-数组缺点" class="headerlink" title="2. 数组缺点"></a>2. 数组缺点</h3><p>1）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。</p><p>2）大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。</p><h3 id="3-链表缺点"><a href="#3-链表缺点" class="headerlink" title="3.链表缺点"></a>3.链表缺点</h3><p>1）内存空间消耗更大，因为需要额外的空间存储指针信息。</p><p>2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。</p><h3 id="4-如何选择？"><a href="#4-如何选择？" class="headerlink" title="4.如何选择？"></a>4.如何选择？</h3><p>数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。</p><p>如果代码对内存的使用非常苛刻，那数组就更适合。</p><h2 id="五、应用"><a href="#五、应用" class="headerlink" title="五、应用"></a>五、应用</h2><h3 id="1-如何分别用链表和数组实现LRU缓冲淘汰策略？"><a href="#1-如何分别用链表和数组实现LRU缓冲淘汰策略？" class="headerlink" title="1. 如何分别用链表和数组实现LRU缓冲淘汰策略？"></a>1. 如何分别用链表和数组实现LRU缓冲淘汰策略？</h3><p>1）什么是缓存？<br>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。</p><p>2）为什么使用缓存？即缓存的特点<br>缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。</p><p>3）什么是缓存淘汰策略？<br>指的是当缓存被用满时清理数据的优先顺序。</p><p>4）有哪些缓存淘汰策略？<br>常见的3种包括先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frenquently Used）、最近最少使用策略LRU（Least Recently Used）。</p><p>5）链表实现LRU缓存淘汰策略<br>当访问的数据没有存储在缓存的链表中时，直接将数据插入链表表头，时间复杂度为O(1)；当访问的数据存在于存储的链表中时，将该数据对应的节点，插入到链表表头,时间复杂度为O(n)。如果缓存被占满，则从链表尾部的数据开始清理，时间复杂度为O(1)。</p><p>6）数组实现LRU缓存淘汰策略</p><p>方式一：首位置保存最新访问数据，末尾位置优先清理<br>当访问的数据未存在于缓存的数组中时，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉末尾的数据，时间复杂度为O(1)。</p><p>方式二：首位置优先清理，末尾位置保存最新访问数据<br>当访问的数据未存在于缓存的数组中时，直接将数据添加进数组作为当前最有一个元素时间复杂度为O(1)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为O(n)。（优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。）</p><h3 id="2-如何通过单链表实现“判断某个字符串是否为水仙花字符串”？（比如-上海自来水来自海上）"><a href="#2-如何通过单链表实现“判断某个字符串是否为水仙花字符串”？（比如-上海自来水来自海上）" class="headerlink" title="2.如何通过单链表实现“判断某个字符串是否为水仙花字符串”？（比如 上海自来水来自海上）"></a>2.如何通过单链表实现“判断某个字符串是否为水仙花字符串”？（比如 上海自来水来自海上）</h3><p>1）前提：字符串以单个字符的形式存储在单链表中。</p><p>2）遍历链表，判断字符个数是否为奇数，若为偶数，则不是。</p><p>3）将链表中的字符倒序存储一份在另一个链表中。</p><p>4）同步遍历2个链表，比较对应的字符是否相等，若相等，则是水仙花字串，否则，不是。</p><h2 id="六、设计思想"><a href="#六、设计思想" class="headerlink" title="六、设计思想"></a>六、设计思想</h2><p>时空替换思想：“用空间换时间” 与 “用时间换空间”<br>当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度小相对较低的算法和数据结构，缓存就是空间换时间的例子。如果内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间的思路。</p><h2 id="七、写链表时的注意项"><a href="#七、写链表时的注意项" class="headerlink" title="七、写链表时的注意项"></a>七、写链表时的注意项</h2><ol><li>如果链表为空时，代码是否能正常工作？</li><li>如果链表只包含一个节点时，代码是否能正常工作？</li><li>如果链表只包含两个节点时，代码是否能正常工作？</li><li>代码逻辑在处理头尾节点时是否能正常工作？</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  王争老师的《数据结构与算法之美》06-07课 链表学习总结 &lt;/p&gt;
&lt;h2 id=&quot;一、什么是链表？&quot;&gt;&lt;a href=&quot;#一、什么是链表？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是链表？&quot;&gt;&lt;/a&gt;一、什么是链表？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-树</title>
    <link href="http://yoursite.com/2018/10/06/leetcode%E5%88%B7%E9%A2%98-%E6%A0%91/"/>
    <id>http://yoursite.com/2018/10/06/leetcode刷题-树/</id>
    <published>2018-10-06T08:58:06.000Z</published>
    <updated>2018-10-06T10:25:26.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h2><h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a>100. 相同的树</h3><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>解题思路：<br>先判空树，然后比较两树的结点值是否相同，再判断p左树空，q左树不空，q右树空，p右树不空的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    boolean flag = true;</span><br><span class="line">    public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if(p==null &amp;&amp; q==null)</span><br><span class="line">            return true;</span><br><span class="line">        if((p != null &amp;&amp; q == null) || (p == null &amp;&amp; q != null))</span><br><span class="line">            return false;</span><br><span class="line"> </span><br><span class="line">        isSame(p,q);</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void isSame(TreeNode p, TreeNode q)&#123;</span><br><span class="line">        if(p.val != q.val)&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if ((p.left == null &amp;&amp; q.left != null) || (p.left != null &amp;&amp; q.left == null))</span><br><span class="line">            flag = false;</span><br><span class="line"> </span><br><span class="line">        if (p.left != null &amp;&amp; q.left != null)&#123;</span><br><span class="line">            isSame(p.left,q.left);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if ((p.right == null &amp;&amp; q.right != null) || (p.right != null &amp;&amp; q.right == null))</span><br><span class="line">            flag = false;</span><br><span class="line"> </span><br><span class="line">        if (p.right != null &amp;&amp; q.right != null)&#123;</span><br><span class="line">            isSame(p.right,q.right);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure></p><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return checkNodes(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean checkNodes(TreeNode node1, TreeNode node2) &#123;</span><br><span class="line">        if (node1 == null &amp;&amp; node2 == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node1 == null || node2 == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node1.val != node2.val) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return checkNodes(node1.left, node2.right) &amp;&amp; checkNodes(node1.right, node2.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7],深度是3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">  </span><br><span class="line">  public int maxDepth(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      int left_height = maxDepth(root.left);</span><br><span class="line">      int right_height = maxDepth(root.right);</span><br><span class="line">      return java.lang.Math.max(left_height, right_height) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>解题思路：<br>所以我们从包含根结点且相应深度为 1 的栈开始。然后我们继续迭代：将当前结点弹出栈并推入子结点。每一步都会更新深度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import javafx.util.Pair;</span><br><span class="line">import java.lang.Math;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">  public int maxDepth(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new LinkedList&lt;&gt;();</span><br><span class="line">    if (root != null) &#123;</span><br><span class="line">      stack.add(new Pair(root, 1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int depth = 0;</span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">      Pair&lt;TreeNode, Integer&gt; current = stack.poll();</span><br><span class="line">      root = current.getKey();</span><br><span class="line">      int current_depth = current.getValue();</span><br><span class="line">      if (root != null) &#123;</span><br><span class="line">        depth = Math.max(depth, current_depth);</span><br><span class="line">        stack.add(new Pair(root.left, current_depth + 1));</span><br><span class="line">        stack.add(new Pair(root.right, current_depth + 1));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return depth;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="107-二叉树的层次遍历-II"><a href="#107-二叉树的层次遍历-II" class="headerlink" title="107. 二叉树的层次遍历 II"></a>107. 二叉树的层次遍历 II</h3><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">      LinkedList&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">      if (root == null) &#123;</span><br><span class="line">          return result;</span><br><span class="line">      &#125;</span><br><span class="line">      Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">      queue.add(root);</span><br><span class="line">      int i = queue.size(); // 记录每层的结点个数</span><br><span class="line">      TreeNode tempNode = null;</span><br><span class="line">      List&lt;Integer&gt; singleLevel = new ArrayList&lt;&gt;();</span><br><span class="line">      while (!queue.isEmpty()) &#123;</span><br><span class="line">          if (i == 0) &#123;// 一层记录结束</span><br><span class="line">              //</span><br><span class="line">              result.addFirst(singleLevel);</span><br><span class="line"></span><br><span class="line">              i = queue.size();</span><br><span class="line">              singleLevel = new ArrayList&lt;&gt;();</span><br><span class="line">          &#125;</span><br><span class="line">          tempNode = queue.poll();</span><br><span class="line">          singleLevel.add(tempNode.val);</span><br><span class="line"></span><br><span class="line">          --i;</span><br><span class="line"></span><br><span class="line">          if (tempNode.left != null) &#123;</span><br><span class="line">              queue.add(tempNode.left);</span><br><span class="line">          &#125;</span><br><span class="line">          if (tempNode.right != null) &#123;</span><br><span class="line">              queue.add(tempNode.right);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      result.addFirst(singleLevel);</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    levelRecursion(root, result, 0);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 递归方法</span><br><span class="line"> */</span><br><span class="line">private void levelRecursion(TreeNode node,</span><br><span class="line">        LinkedList&lt;List&lt;Integer&gt;&gt; result, int level) &#123;</span><br><span class="line">    if (node == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (result.size() &lt; level + 1) &#123;// 说明还需要添加一行</span><br><span class="line">        result.addFirst(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    result.get(result.size() - 1 - level).add(node.val);</span><br><span class="line"></span><br><span class="line">    levelRecursion(node.left, result, level + 1);</span><br><span class="line">    levelRecursion(node.right, result, level + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h2><h4 id="树的遍历-DFS思想"><a href="#树的遍历-DFS思想" class="headerlink" title="树的遍历(DFS思想)"></a>树的遍历(DFS思想)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     A</span><br><span class="line">    / \</span><br><span class="line">   B   C</span><br><span class="line"> /  \  / \</span><br><span class="line">D   E  F  G   </span><br><span class="line">\</span><br><span class="line">H</span><br></pre></td></tr></table></figure><ol><li><p>中序遍历:左子树——》根节点——》右子树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void infixOrder(Node current)&#123;</span><br><span class="line">    if(current != null)&#123;</span><br><span class="line">        infixOrder(current.leftChild);</span><br><span class="line">        System.out.print(current.data+&quot; &quot;);</span><br><span class="line">        infixOrder(current.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>前序遍历:根节点——》左子树——》右子树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void preOrder(Node current)&#123;</span><br><span class="line">    if(current != null)&#123;</span><br><span class="line">        System.out.print(current.data+&quot; &quot;);</span><br><span class="line">        preOrder(current.leftChild);</span><br><span class="line">        preOrder(current.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历:左子树——》右子树——》根节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void postOrder(Node current)&#123;</span><br><span class="line">    if(current != null)&#123;</span><br><span class="line">        postOrder(current.leftChild);</span><br><span class="line">        postOrder(current.rightChild);</span><br><span class="line">        System.out.print(current.data+&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简单题&quot;&gt;&lt;a href=&quot;#简单题&quot; class=&quot;headerlink&quot; title=&quot;简单题&quot;&gt;&lt;/a&gt;简单题&lt;/h2&gt;&lt;h3 id=&quot;100-相同的树&quot;&gt;&lt;a href=&quot;#100-相同的树&quot; class=&quot;headerlink&quot; title=&quot;100. 
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-数组</title>
    <link href="http://yoursite.com/2018/09/27/leetcode%E5%88%B7%E9%A2%98-%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/09/27/leetcode刷题-数组/</id>
    <published>2018-09-27T12:20:24.000Z</published>
    <updated>2018-09-27T12:22:58.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h2><h3 id="1-给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。"><a href="#1-给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。" class="headerlink" title="1.给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。"></a>1.给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</h3><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。<br>给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0,1]。</p><h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">       for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">        for(int j=i+1;j&lt;nums.length;j++)&#123;</span><br><span class="line">            if(nums[i]+nums[j] == target)&#123;</span><br><span class="line">                return new int[] &#123;i,j&#125;;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      throw new IllegalArgumentException(&quot;No two sum solution&quot;);  </span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两遍哈希表"><a href="#两遍哈希表" class="headerlink" title="两遍哈希表"></a>两遍哈希表</h4><p>在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]target−nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i]nums[i] 本身！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">       Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">       for(int i=0;i&lt; nums.length;i++)&#123;</span><br><span class="line">           map.put(nums[i],i);</span><br><span class="line">       &#125;</span><br><span class="line">       for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">          int complement = target - nums[i];</span><br><span class="line">           if(map.containsKey(complement) &amp;&amp; map.get(complement)!=i)&#123;</span><br><span class="line">              return new int[]&#123; i,map.get(complement) &#125;; </span><br><span class="line">           &#125;</span><br><span class="line">               </span><br><span class="line">       &#125;</span><br><span class="line">           </span><br><span class="line">     throw new IllegalArgumentException(&quot;No two sum solution&quot;);  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="一遍哈希表"><a href="#一遍哈希表" class="headerlink" title="一遍哈希表"></a>一遍哈希表</h4><p> 在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> class Solution &#123;</span><br><span class="line">   public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">       Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">       for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">          int complement = target - nums[i];</span><br><span class="line">           if(map.containsKey(complement))&#123;</span><br><span class="line">              return new int[]&#123; map.get(complement) ,i&#125;; </span><br><span class="line">           &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">       &#125;</span><br><span class="line">           </span><br><span class="line">     throw new IllegalArgumentException(&quot;No two sum solution&quot;);  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简单题&quot;&gt;&lt;a href=&quot;#简单题&quot; class=&quot;headerlink&quot; title=&quot;简单题&quot;&gt;&lt;/a&gt;简单题&lt;/h2&gt;&lt;h3 id=&quot;1-给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。&quot;&gt;&lt;a href=&quot;#1-给定一个整数数组和一个目标值，
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-链表</title>
    <link href="http://yoursite.com/2018/09/27/leetcode%E5%88%B7%E9%A2%98-ListNode/"/>
    <id>http://yoursite.com/2018/09/27/leetcode刷题-ListNode/</id>
    <published>2018-09-27T08:19:30.000Z</published>
    <updated>2018-10-03T01:45:11.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h2><h3 id="21-将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。"><a href="#21-将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。" class="headerlink" title="21.将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。"></a>21.将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</h3><p>eg:输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p>思路：每次都取两个中较小的一个，直到其中一个遍历到链表结尾结束遍历。如果这个时候还是剩下的元素，肯定比之前的元素都大，直接添加到链表结尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        if(l1 == null)</span><br><span class="line">        &#123;</span><br><span class="line">            return l2;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l2 ==null)</span><br><span class="line">        &#123;</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode merged =null;</span><br><span class="line">        ListNode head =null;</span><br><span class="line">        while(l1!=null &amp;&amp;l2!=null)&#123;</span><br><span class="line">            if(head ==null)&#123;</span><br><span class="line">                if(l1.val &lt;l2.val)&#123;</span><br><span class="line">                    merged =l1;</span><br><span class="line">                    l1=l1.next;</span><br><span class="line">                    </span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    merged =l2;</span><br><span class="line">                    l2=l2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                head =merged;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l1.val&lt;l2.val)&#123;</span><br><span class="line">                merged.next =l1;</span><br><span class="line">                l1 =l1.next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                merged.next =l2;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            merged =merged.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(l1 !=null)&#123;</span><br><span class="line">            merged.next =l1;</span><br><span class="line">            l1=l1.next;</span><br><span class="line">            merged=merged.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(l2 !=null)&#123;</span><br><span class="line">            merged.next =l2;</span><br><span class="line">            l2=l2.next;</span><br><span class="line">            merged=merged.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h3><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2</p><p>示例 2:</p><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p><p>解题思路：如果是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        ListNode current =head;</span><br><span class="line">        while(current !=null&amp;&amp;current.next !=null )&#123;</span><br><span class="line">            if(current.val==current.next.val)&#123;</span><br><span class="line">                current.next=current.next.next;&#125;</span><br><span class="line">            </span><br><span class="line">                else&#123;</span><br><span class="line">                    current=current.next;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">           return head;    </span><br><span class="line">        &#125;</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h3><p>给定一个链表，判断链表中是否有环。</p><h3 id="hash法"><a href="#hash法" class="headerlink" title="hash法"></a>hash法</h3><p>我们遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。如果当前结点为空结点 null（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。如果当前结点的引用已经存在于哈希表中，那么返回 true（即该链表为环形链表）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">    Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;();</span><br><span class="line">    while (head != null) &#123;</span><br><span class="line">        if (nodesSeen.contains(head)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            nodesSeen.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>通过使用具有不同速度的快、慢两个指针遍历链表，空间复杂度可以被降低至O(1)O(1)。慢指针每次移动一步，而快指针每次移动两步。</p><p>如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//查询是否有环（双向链表）</span><br><span class="line">public boolean hasCycle1(ListNode head) &#123;</span><br><span class="line">    if (head == null || head.next == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    while (slow != fast) &#123;</span><br><span class="line">        if (fast == null || fast.next == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h3><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>A:          a1 → a2<br>                   ↘<br>                     c1 → c2 → c3<br>                   ↗<br>B:     b1 → b2 → b3</p><p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p><p>解题思路：如果A和B是两个长度不同的链表，他们相交前的长度一定是不同的，计算链表长度差额n，让长的链表指针先开始移动n，两个指针再一起移动，指针相遇时就是链表结点的相交处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        int lengthA=calcListLength(headA);</span><br><span class="line">        int lengthB=calcListLength(headB);</span><br><span class="line">        int lenc=lengthA-lengthB;</span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;Math.abs(lenc);i++)&#123;</span><br><span class="line">            if(lenc&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                headA=headA.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                headB=headB.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while( headA !=null &amp;&amp; headB !=null)&#123;</span><br><span class="line">            if(headA == headB)&#123;</span><br><span class="line">                return headA;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            headA=headA.next;</span><br><span class="line">            headB=headB.next;</span><br><span class="line">    </span><br><span class="line">    &#125;   </span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int calcListLength(ListNode Node)&#123;</span><br><span class="line">        ListNode head=Node;</span><br><span class="line">        int i=0;</span><br><span class="line">        while(head !=null)&#123;</span><br><span class="line">            head=head.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h3><p>反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123; //先考虑链表是否为空</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head.next;</span><br><span class="line">        p1.next = null;</span><br><span class="line">        while (p2 != null) &#123;</span><br><span class="line">            ListNode temp = p2.next;</span><br><span class="line">            //设置一个tmp指针指向后续</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            //p2指针反转</span><br><span class="line">            p1 = p2;</span><br><span class="line">            //p1指针向前进</span><br><span class="line">            p2 = temp;  </span><br><span class="line">            //p2指针向前进</span><br><span class="line">        &#125;</span><br><span class="line">        return p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><p>解题思路：<br>假设1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null<br>已经变成1-&gt;2&lt;-3&lt;-4&lt;-5&lt;-null</p><p>2是<code>head.next</code></p><p>2的后继是<code>head.next.next</code></p><p>我们希望2的后继指向head所以是head=head.next.next</p><p>再去除1-&gt;2的环<code>head.next=null</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode subListHead = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = null;</span><br><span class="line">        return subListHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中等题"><a href="#中等题" class="headerlink" title="中等题"></a>中等题</h2><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h3><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p><p>输出：7 -&gt; 0 -&gt; 8</p><p>原因：342 + 465 = 807</p><h4 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">               ListNode dummyHead = new ListNode(0);</span><br><span class="line">               ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">               int carry = 0;</span><br><span class="line">               while (p != null || q != null) &#123;</span><br><span class="line">                   int x = (p != null) ? p.val : 0;</span><br><span class="line">                   int y = (q != null) ? q.val : 0;</span><br><span class="line">                   int sum = carry + x + y;</span><br><span class="line">                   carry = sum / 10;</span><br><span class="line">                   curr.next = new ListNode(sum % 10);</span><br><span class="line">                   curr = curr.next;</span><br><span class="line">                   if (p != null) p = p.next;</span><br><span class="line">                   if (q != null) q = q.next;</span><br><span class="line">               &#125;</span><br><span class="line">               if (carry &gt; 0) &#123;</span><br><span class="line">                   curr.next = new ListNode(carry);</span><br><span class="line">               &#125;</span><br><span class="line">               return dummyHead.next;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><h4 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"> public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">    if (l1 == null || l2 == null) &#123;</span><br><span class="line">        return l1 == null ? l2 : l1;</span><br><span class="line">    &#125;</span><br><span class="line">    int value = l1.val + l2.val;</span><br><span class="line">    ListNode result = new ListNode(value % 10);</span><br><span class="line">    //节点相加</span><br><span class="line">    result.next = addTwoNumbers(l1.next, l2.next);</span><br><span class="line">    //节点相加的结果和余数相加.</span><br><span class="line">    if (value &gt;= 10) &#123;</span><br><span class="line">        result.next = addTwoNumbers(new ListNode(value / 10),</span><br><span class="line">                      result.next);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h2><p>ListNode的类结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode</span><br><span class="line">&#123;</span><br><span class="line">    int val;//定义val变量值，存储节点值</span><br><span class="line">    ListNode next;//定义next指针，指向下一个节点，维持节点连接</span><br><span class="line">    </span><br><span class="line">    public ListNode(int x)&#123;</span><br><span class="line">        val=x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>注意注意val只代表当前指针的值，比如p-&gt;val表示p指针的指向的值；而p-&gt;next表示链表下一个节点，也是一个指针。</li><li>构造函数包含两个参数 _value 和 _next ，分别用来给节点赋值和指定下一节点</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简单题&quot;&gt;&lt;a href=&quot;#简单题&quot; class=&quot;headerlink&quot; title=&quot;简单题&quot;&gt;&lt;/a&gt;简单题&lt;/h2&gt;&lt;h3 id=&quot;21-将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Quick Start</title>
    <link href="http://yoursite.com/2018/09/27/hexo-Quick-start/"/>
    <id>http://yoursite.com/2018/09/27/hexo-Quick-start/</id>
    <published>2018-09-27T07:17:48.000Z</published>
    <updated>2018-10-07T08:03:19.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1. 安装hexo"></a>1. 安装hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo</span><br></pre></td></tr></table></figure><p>目录结构</p><ul><li>node_modules：是依赖包</li><li>public：存放的是生成的页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：用命令创建的各种文章</li><li>themes：主题</li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul><h2 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">hexo install</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>此时打开<a href="http://localhost:4000可以看到静态页" target="_blank" rel="noopener">http://localhost:4000可以看到静态页</a></p><h2 id="3-关联github"><a href="#3-关联github" class="headerlink" title="3.  关联github"></a>3.  关联github</h2><h4 id="gitbash连接"><a href="#gitbash连接" class="headerlink" title="gitbash连接"></a>gitbash连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱&quot;</span><br><span class="line">ssh-keygen -t rsa -C&quot;邮箱&quot;</span><br></pre></td></tr></table></figure><p>找到ssh key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure></p><p>将这段配置到github上后，检查一下是否配置成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>创建项目名为：用户名.github.io<br>在/blog下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/用户名/用户名.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>退出保存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><p>hexo d时提示ERROR Deployer not found:git</p><p>解决方法：<br>npm install –save hexo-deployer-git</p><h2 id="4-配置主题"><a href="#4-配置主题" class="headerlink" title="4. 配置主题"></a>4. 配置主题</h2><p>这边使用了yilia</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><p>修改hexo根目录下的 _config.yml<code>theme: yilia</code></p></li><li><p>配置yilia文件下的_config.yml</p></li></ul><p>配置头像时出现了头像不能展示的问题</p><p>解决方法：</p><ul><li><p>layout/_partial/left-col.ejs将第六行修改成如下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;&lt;%=theme.root%&gt;&lt;%=theme.avatar%&gt;&quot; class=&quot;js-avatar&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>将头像文件放在theme/source/img目录下，修改yilia的配置文件<br><code>avatar: img/myicon.jpg</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-安装hexo&quot;&gt;&lt;a href=&quot;#1-安装hexo&quot; class=&quot;headerlink&quot; title=&quot;1. 安装hexo&quot;&gt;&lt;/a&gt;1. 安装hexo&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/09/27/hello-world/"/>
    <id>http://yoursite.com/2018/09/27/hello-world/</id>
    <published>2018-09-27T02:53:18.075Z</published>
    <updated>2018-09-27T02:53:18.075Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
