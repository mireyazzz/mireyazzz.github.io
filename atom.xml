<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-07T06:30:04.642Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mireyazzz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>留下没有基础的眼泪-synchronized</title>
    <link href="http://yoursite.com/2018/10/07/%E7%95%99%E4%B8%8B%E6%B2%A1%E6%9C%89%E5%9F%BA%E7%A1%80%E7%9A%84%E7%9C%BC%E6%B3%AA-synchronized/"/>
    <id>http://yoursite.com/2018/10/07/留下没有基础的眼泪-synchronized/</id>
    <published>2018-10-07T06:28:48.000Z</published>
    <updated>2018-10-07T06:30:04.642Z</updated>
    
    <content type="html"><![CDATA[<p>杨晓峰老师《java核心技术36讲》15，16课&amp;郑雨迪老师《深入拆解java虚拟机》14课学习总结</p><p>参考文章：<a href="https://www.cnblogs.com/charlesblc/p/5994162.html" target="_blank" rel="noopener">https://www.cnblogs.com/charlesblc/p/5994162.html</a></p><h2 id="synchronized的实现原理"><a href="#synchronized的实现原理" class="headerlink" title="synchronized的实现原理"></a>synchronized的实现原理</h2><p>在java程序中，我们利用synchronized关键字来对程序进行加锁，它可以申明一个synchronized代码块，也可以标记静态方法或者实例方法。</p><h3 id="1-声明synchronized-代码块"><a href="#1-声明synchronized-代码块" class="headerlink" title="1.声明synchronized 代码块"></a>1.声明synchronized 代码块</h3><p>是由一对 monitorenter/monitorexit指令实现的，monitor 对象是同步的基本实现单元。</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void foo(Object lock) &#123;</span><br><span class="line">  synchronized (lock) &#123;</span><br><span class="line">    lock.hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码编译的字节码会包括一个monitorenter指令和多个monitorexit，jvm需要确保所获得的锁在正常/异常执行路径都能够被解锁。</p><p>执行monitorenter时</p><ul><li>如果目标锁的计数器为0，说明他没有被其他线程所持有，jvm会将锁对象的持有线程设置为当前线程，并将计数器加1.</li><li>如果目标锁的计数器不为0，如果锁对象的持有线程是当前线程，jvm可以将计数器加1，否则等待，直到持有线程释放该锁。</li></ul><p>执行monitorexit时，jvm将锁对象的计数器减1，如果计数器为0，代表锁已经被释放。</p><h3 id="2-用synchronized标记方法"><a href="#2-用synchronized标记方法" class="headerlink" title="2.用synchronized标记方法"></a>2.用synchronized标记方法</h3><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void foo(Object lock) &#123;</span><br><span class="line">  lock.hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码编译的字节码中方法的访问有ACC_SYNCHRONIZED。但是没有monitorenter或者monitorexit。</p><p>因为方法级别的同步是隐式的，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构（method_info structure）中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否是同步方法。</p><p>当调用方法时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否设置，如果设置了，执行线程先持有同步锁，然后执行方法，最后在方法完成时释放锁。</p><h2 id="锁的升级降级"><a href="#锁的升级降级" class="headerlink" title="锁的升级降级"></a>锁的升级降级</h2><ul><li>jvm 提供三种不同的Monitor实现，即偏斜锁，轻量锁，重量锁。</li><li>当jvm检测到不同的竞争状况时，会自动切换到适合的锁实现，这就是锁的升级降级。</li><li>当没有竞争出现时，默认使用偏斜锁。</li></ul><p><img src="https://wiki.openjdk.java.net/download/attachments/11829266/Synchronization.gif?version=4&amp;modificationDate=1208918680000&amp;api=v2" alt="image"><br>其中，00代表轻量锁，01代表无锁（或者偏向锁），10代表重量锁，11则根垃圾回收算法的标记有关。</p><p>在所有的锁都启用的情况下线程进入临界区时会先去获取偏向锁，如果已经存在偏向锁了，则会尝试获取轻量级锁，如果以上两种都失败，则启用自旋锁，如果自旋也没有获取到锁，则使用重量级锁，没有获取到锁的线程阻塞挂起，直到持有锁的线程执行完同步块唤醒他们；</p><h3 id="重量锁"><a href="#重量锁" class="headerlink" title="重量锁"></a>重量锁</h3><p>重量锁会阻碍加锁失败的线程，并在目标锁被释放时唤醒这些线程。<br>为了避免昂贵的线程阻塞，唤醒的过程，jvm会在线程进入阻塞状态之前，以及被唤醒后竞争不到锁的情况下，进入自旋状态，在处理器上空跑并轮询锁是否释放，如果此时锁恰好被释放了，那线程便无须进入阻塞状态，直接获得这把锁。</p><h3 id="轻量锁"><a href="#轻量锁" class="headerlink" title="轻量锁"></a>轻量锁</h3><p>轻量级锁是相对于重量级锁而言在获取锁和释放锁时更加高效，但轻量级锁并不能代替重量级锁。轻量级锁适用的场景是在线程交替获取某个锁执行同步代码块的场景，如果出现多个进程同时竞争同一个锁时，轻量级锁会膨胀成重量级锁。</p><p>轻量锁采用CAS操作，把锁对象的标记字段替换成一个指针，指向当前线程栈上的一块空间，存储这锁对象原本的标记字段。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p> 偏向锁只会在第一次请求是采用CAS操作，在锁对象的标记字段中记录下当前线程的地址，在之后的运行过程中，持有该偏向锁的线程的加锁操作将直接返回。</p><table><thead><tr><th>锁</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>重量锁</td><td>多个线程同时进入临界区</td><td>线程竞争不使用自旋不消耗cpu，吞吐量高</td><td>线程阻塞，响应缓慢</td></tr><tr><td>轻量锁</td><td>多个线程交替进入临界区</td><td>竞争的线程不会阻塞，响应速度快</td><td>如果始终得不到锁竞争的线程使用自旋会消耗cpu</td></tr><tr><td>偏向锁</td><td>仅有一个线程进入临界区</td><td>加锁和解锁不需要额外的消耗</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td></tr></tbody></table><h2 id="ReentrantLock和synchronized的区别"><a href="#ReentrantLock和synchronized的区别" class="headerlink" title="ReentrantLock和synchronized的区别"></a>ReentrantLock和synchronized的区别</h2><p>1.用法比较</p><ul><li>Lock使用起来比较灵活，但是必须有释放锁的配合动作</li><li>Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁</li><li>Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等</li></ul><p>2.特性比较</p><p>ReentrantLock的优势体现在：</p><ul><li>具备尝试非阻塞地获取锁的特性：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁</li><li>能被中断地获取锁的特性：与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</li><li>超时获取锁的特性：在指定的时间范围内获取锁；如果截止时间到了仍然无法获取锁，则返回</li></ul><p>3.注意事项</p><p>在使用ReentrantLock类的时，一定要注意三点：</p><ul><li>在finally中释放锁，目的是保证在获取锁之后，最终能够被释放</li><li>不要将获取锁的过程写在try块内，因为如果在获取锁时发生了异常，异常抛出的同时，也会导致锁无故被释放。</li><li>ReentrantLock提供了一个newCondition的方法，以便用户在同一锁的情况下可以根据不同的情况执行等待或唤醒的动作。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;杨晓峰老师《java核心技术36讲》15，16课&amp;amp;郑雨迪老师《深入拆解java虚拟机》14课学习总结&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://www.cnblogs.com/charlesblc/p/5994162.html&quot; target=&quot;_b
      
    
    </summary>
    
    
      <category term="synchronized" scheme="http://yoursite.com/tags/synchronized/"/>
    
      <category term="同步" scheme="http://yoursite.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>留下没有基础的眼泪-链表</title>
    <link href="http://yoursite.com/2018/10/06/%E7%95%99%E4%B8%8B%E6%B2%A1%E6%9C%89%E5%9F%BA%E7%A1%80%E7%9A%84%E7%9C%BC%E6%B3%AA-%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/10/06/留下没有基础的眼泪-链表/</id>
    <published>2018-10-06T11:10:17.000Z</published>
    <updated>2018-10-06T11:13:17.169Z</updated>
    
    <content type="html"><![CDATA[<p>  王争老师的《数据结构与算法之美》06-07课 链表学习总结 </p><h2 id="一、什么是链表？"><a href="#一、什么是链表？" class="headerlink" title="一、什么是链表？"></a>一、什么是链表？</h2><ol><li>和数组一样，链表也是一种线性表。</li><li>从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。</li><li>链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。</li></ol><h2 id="二、链表的特点"><a href="#二、链表的特点" class="headerlink" title="二、链表的特点"></a>二、链表的特点</h2><ol><li>插入、删除数据效率高O(1)级别（只需更改指针指向即可），随机访问效率低O(n)级别（需要从链头至链尾进行遍历）。</li><li>和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。</li></ol><h2 id="三、常用链表：单链表、循环链表和双向链表"><a href="#三、常用链表：单链表、循环链表和双向链表" class="headerlink" title="三、常用链表：单链表、循环链表和双向链表"></a>三、常用链表：单链表、循环链表和双向链表</h2><h3 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1. 单链表"></a>1. 单链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private class Node &#123;</span><br><span class="line">    private Object data;        //数据</span><br><span class="line">    private Node next = null;  //指针域</span><br><span class="line"></span><br><span class="line">    public Node() &#123;                         //无参数构造函数为了创建头结点服务</span><br><span class="line">        data = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node(E data) &#123;                //带数据的构造函数</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    private Node head;               //头引用（指针）</span><br><span class="line">    private Node tail;                //尾引用（指针）</span><br><span class="line">    private Node point;              //临时引用（指针）</span><br><span class="line">    private int length;                 </span><br><span class="line">    //链表长度</span><br><span class="line"></span><br><span class="line">    public nodeList() &#123;                  //链表构造函数，创建无数据的头结点</span><br><span class="line">        head = new Node();</span><br><span class="line">        tail = head;</span><br><span class="line">        length = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><p><img src="http://oyfmp3adh.bkt.clouddn.com/%E6%9C%AA%E5%91%BD%E5%90%8D1520232582.png" alt="image"></p><p>让p的后继结点改成s的后继结点，再把结点s变成p的后继结点</p><p><code>s-&gt;next=p-&gt;next; p-&gt;next=s;</code><br>具体实现如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void insert(int position, E elem) &#123;</span><br><span class="line">    if (position &gt;= 0 &amp;&amp; position &lt;= length) &#123;</span><br><span class="line">        point = movePoint(position);</span><br><span class="line">        Node tmp = new Node(elem);</span><br><span class="line">        tmp.next = point.next;</span><br><span class="line">        point.next = tmp;</span><br><span class="line">        length++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        System.out.println(&quot;没有指定位置，插入失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>每个节点只包含一个指针，即后继指针。</li><li>单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。</li><li>性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)。<h3 id="2-循环链表"><a href="#2-循环链表" class="headerlink" title="2. 循环链表"></a>2. 循环链表</h3><img src="https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg" alt="image"></li><li>除了尾节点的后继指针指向首节点的地址外均与单链表一致。</li><li>适用于存储有循环特点的数据，比如约瑟夫问题。<h3 id="3-双向链表"><a href="#3-双向链表" class="headerlink" title="3.双向链表"></a>3.双向链表</h3><img src="https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg" alt="image"></li><li>节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。</li><li>首节点的前驱指针prev和尾节点的后继指针均指向空地址。</li><li>性能特点：和单链表相比，存储相同的数据，需要消耗更多的存储空间。</li></ul><p>插入、删除操作比单链表效率更高O(1)级别。以删除操作为例，删除操作分为2种情况：</p><ol><li>给定数据值删除对应节点。</li><li>给定节点地址删除节点。</li></ol><p>对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。</p><p>对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p-&gt;next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。<br>对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p><h3 id="4-双向循环链表"><a href="#4-双向循环链表" class="headerlink" title="4.双向循环链表"></a>4.双向循环链表</h3><p><img src="https://static001.geekbang.org/resource/image/d1/91/d1665043b283ecdf79b157cfc9e5ed91.jpg" alt="image"><br>首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。</p><h2 id="四、选择数组还是链表？"><a href="#四、选择数组还是链表？" class="headerlink" title="四、选择数组还是链表？"></a>四、选择数组还是链表？</h2><h3 id="1-插入、删除和随机访问的时间复杂度"><a href="#1-插入、删除和随机访问的时间复杂度" class="headerlink" title="1. 插入、删除和随机访问的时间复杂度"></a>1. 插入、删除和随机访问的时间复杂度</h3><p>数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。</p><p>链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。</p><h3 id="2-数组缺点"><a href="#2-数组缺点" class="headerlink" title="2. 数组缺点"></a>2. 数组缺点</h3><p>1）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。</p><p>2）大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。</p><h3 id="3-链表缺点"><a href="#3-链表缺点" class="headerlink" title="3.链表缺点"></a>3.链表缺点</h3><p>1）内存空间消耗更大，因为需要额外的空间存储指针信息。</p><p>2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。</p><h3 id="4-如何选择？"><a href="#4-如何选择？" class="headerlink" title="4.如何选择？"></a>4.如何选择？</h3><p>数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。</p><p>如果代码对内存的使用非常苛刻，那数组就更适合。</p><h2 id="五、应用"><a href="#五、应用" class="headerlink" title="五、应用"></a>五、应用</h2><h3 id="1-如何分别用链表和数组实现LRU缓冲淘汰策略？"><a href="#1-如何分别用链表和数组实现LRU缓冲淘汰策略？" class="headerlink" title="1. 如何分别用链表和数组实现LRU缓冲淘汰策略？"></a>1. 如何分别用链表和数组实现LRU缓冲淘汰策略？</h3><p>1）什么是缓存？<br>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。</p><p>2）为什么使用缓存？即缓存的特点<br>缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。</p><p>3）什么是缓存淘汰策略？<br>指的是当缓存被用满时清理数据的优先顺序。</p><p>4）有哪些缓存淘汰策略？<br>常见的3种包括先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frenquently Used）、最近最少使用策略LRU（Least Recently Used）。</p><p>5）链表实现LRU缓存淘汰策略<br>当访问的数据没有存储在缓存的链表中时，直接将数据插入链表表头，时间复杂度为O(1)；当访问的数据存在于存储的链表中时，将该数据对应的节点，插入到链表表头,时间复杂度为O(n)。如果缓存被占满，则从链表尾部的数据开始清理，时间复杂度为O(1)。</p><p>6）数组实现LRU缓存淘汰策略</p><p>方式一：首位置保存最新访问数据，末尾位置优先清理<br>当访问的数据未存在于缓存的数组中时，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉末尾的数据，时间复杂度为O(1)。</p><p>方式二：首位置优先清理，末尾位置保存最新访问数据<br>当访问的数据未存在于缓存的数组中时，直接将数据添加进数组作为当前最有一个元素时间复杂度为O(1)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为O(n)。（优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。）</p><h3 id="2-如何通过单链表实现“判断某个字符串是否为水仙花字符串”？（比如-上海自来水来自海上）"><a href="#2-如何通过单链表实现“判断某个字符串是否为水仙花字符串”？（比如-上海自来水来自海上）" class="headerlink" title="2.如何通过单链表实现“判断某个字符串是否为水仙花字符串”？（比如 上海自来水来自海上）"></a>2.如何通过单链表实现“判断某个字符串是否为水仙花字符串”？（比如 上海自来水来自海上）</h3><p>1）前提：字符串以单个字符的形式存储在单链表中。</p><p>2）遍历链表，判断字符个数是否为奇数，若为偶数，则不是。</p><p>3）将链表中的字符倒序存储一份在另一个链表中。</p><p>4）同步遍历2个链表，比较对应的字符是否相等，若相等，则是水仙花字串，否则，不是。</p><h2 id="六、设计思想"><a href="#六、设计思想" class="headerlink" title="六、设计思想"></a>六、设计思想</h2><p>时空替换思想：“用空间换时间” 与 “用时间换空间”<br>当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度小相对较低的算法和数据结构，缓存就是空间换时间的例子。如果内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间的思路。</p><h2 id="七、写链表时的注意项"><a href="#七、写链表时的注意项" class="headerlink" title="七、写链表时的注意项"></a>七、写链表时的注意项</h2><ol><li>如果链表为空时，代码是否能正常工作？</li><li>如果链表只包含一个节点时，代码是否能正常工作？</li><li>如果链表只包含两个节点时，代码是否能正常工作？</li><li>代码逻辑在处理头尾节点时是否能正常工作？</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  王争老师的《数据结构与算法之美》06-07课 链表学习总结 &lt;/p&gt;
&lt;h2 id=&quot;一、什么是链表？&quot;&gt;&lt;a href=&quot;#一、什么是链表？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是链表？&quot;&gt;&lt;/a&gt;一、什么是链表？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-树</title>
    <link href="http://yoursite.com/2018/10/06/leetcode%E5%88%B7%E9%A2%98-%E6%A0%91/"/>
    <id>http://yoursite.com/2018/10/06/leetcode刷题-树/</id>
    <published>2018-10-06T08:58:06.000Z</published>
    <updated>2018-10-06T10:25:26.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h2><h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a>100. 相同的树</h3><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>解题思路：<br>先判空树，然后比较两树的结点值是否相同，再判断p左树空，q左树不空，q右树空，p右树不空的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    boolean flag = true;</span><br><span class="line">    public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if(p==null &amp;&amp; q==null)</span><br><span class="line">            return true;</span><br><span class="line">        if((p != null &amp;&amp; q == null) || (p == null &amp;&amp; q != null))</span><br><span class="line">            return false;</span><br><span class="line"> </span><br><span class="line">        isSame(p,q);</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void isSame(TreeNode p, TreeNode q)&#123;</span><br><span class="line">        if(p.val != q.val)&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if ((p.left == null &amp;&amp; q.left != null) || (p.left != null &amp;&amp; q.left == null))</span><br><span class="line">            flag = false;</span><br><span class="line"> </span><br><span class="line">        if (p.left != null &amp;&amp; q.left != null)&#123;</span><br><span class="line">            isSame(p.left,q.left);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if ((p.right == null &amp;&amp; q.right != null) || (p.right != null &amp;&amp; q.right == null))</span><br><span class="line">            flag = false;</span><br><span class="line"> </span><br><span class="line">        if (p.right != null &amp;&amp; q.right != null)&#123;</span><br><span class="line">            isSame(p.right,q.right);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure></p><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return checkNodes(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean checkNodes(TreeNode node1, TreeNode node2) &#123;</span><br><span class="line">        if (node1 == null &amp;&amp; node2 == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node1 == null || node2 == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node1.val != node2.val) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return checkNodes(node1.left, node2.right) &amp;&amp; checkNodes(node1.right, node2.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7],深度是3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">  </span><br><span class="line">  public int maxDepth(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      int left_height = maxDepth(root.left);</span><br><span class="line">      int right_height = maxDepth(root.right);</span><br><span class="line">      return java.lang.Math.max(left_height, right_height) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>解题思路：<br>所以我们从包含根结点且相应深度为 1 的栈开始。然后我们继续迭代：将当前结点弹出栈并推入子结点。每一步都会更新深度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import javafx.util.Pair;</span><br><span class="line">import java.lang.Math;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">  public int maxDepth(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new LinkedList&lt;&gt;();</span><br><span class="line">    if (root != null) &#123;</span><br><span class="line">      stack.add(new Pair(root, 1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int depth = 0;</span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">      Pair&lt;TreeNode, Integer&gt; current = stack.poll();</span><br><span class="line">      root = current.getKey();</span><br><span class="line">      int current_depth = current.getValue();</span><br><span class="line">      if (root != null) &#123;</span><br><span class="line">        depth = Math.max(depth, current_depth);</span><br><span class="line">        stack.add(new Pair(root.left, current_depth + 1));</span><br><span class="line">        stack.add(new Pair(root.right, current_depth + 1));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return depth;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="107-二叉树的层次遍历-II"><a href="#107-二叉树的层次遍历-II" class="headerlink" title="107. 二叉树的层次遍历 II"></a>107. 二叉树的层次遍历 II</h3><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">      LinkedList&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">      if (root == null) &#123;</span><br><span class="line">          return result;</span><br><span class="line">      &#125;</span><br><span class="line">      Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">      queue.add(root);</span><br><span class="line">      int i = queue.size(); // 记录每层的结点个数</span><br><span class="line">      TreeNode tempNode = null;</span><br><span class="line">      List&lt;Integer&gt; singleLevel = new ArrayList&lt;&gt;();</span><br><span class="line">      while (!queue.isEmpty()) &#123;</span><br><span class="line">          if (i == 0) &#123;// 一层记录结束</span><br><span class="line">              //</span><br><span class="line">              result.addFirst(singleLevel);</span><br><span class="line"></span><br><span class="line">              i = queue.size();</span><br><span class="line">              singleLevel = new ArrayList&lt;&gt;();</span><br><span class="line">          &#125;</span><br><span class="line">          tempNode = queue.poll();</span><br><span class="line">          singleLevel.add(tempNode.val);</span><br><span class="line"></span><br><span class="line">          --i;</span><br><span class="line"></span><br><span class="line">          if (tempNode.left != null) &#123;</span><br><span class="line">              queue.add(tempNode.left);</span><br><span class="line">          &#125;</span><br><span class="line">          if (tempNode.right != null) &#123;</span><br><span class="line">              queue.add(tempNode.right);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      result.addFirst(singleLevel);</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    levelRecursion(root, result, 0);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 递归方法</span><br><span class="line"> */</span><br><span class="line">private void levelRecursion(TreeNode node,</span><br><span class="line">        LinkedList&lt;List&lt;Integer&gt;&gt; result, int level) &#123;</span><br><span class="line">    if (node == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (result.size() &lt; level + 1) &#123;// 说明还需要添加一行</span><br><span class="line">        result.addFirst(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    result.get(result.size() - 1 - level).add(node.val);</span><br><span class="line"></span><br><span class="line">    levelRecursion(node.left, result, level + 1);</span><br><span class="line">    levelRecursion(node.right, result, level + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h2><h4 id="树的遍历-DFS思想"><a href="#树的遍历-DFS思想" class="headerlink" title="树的遍历(DFS思想)"></a>树的遍历(DFS思想)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     A</span><br><span class="line">    / \</span><br><span class="line">   B   C</span><br><span class="line"> /  \  / \</span><br><span class="line">D   E  F  G   </span><br><span class="line">\</span><br><span class="line">H</span><br></pre></td></tr></table></figure><ol><li><p>中序遍历:左子树——》根节点——》右子树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void infixOrder(Node current)&#123;</span><br><span class="line">    if(current != null)&#123;</span><br><span class="line">        infixOrder(current.leftChild);</span><br><span class="line">        System.out.print(current.data+&quot; &quot;);</span><br><span class="line">        infixOrder(current.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>前序遍历:根节点——》左子树——》右子树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void preOrder(Node current)&#123;</span><br><span class="line">    if(current != null)&#123;</span><br><span class="line">        System.out.print(current.data+&quot; &quot;);</span><br><span class="line">        preOrder(current.leftChild);</span><br><span class="line">        preOrder(current.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历:左子树——》右子树——》根节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void postOrder(Node current)&#123;</span><br><span class="line">    if(current != null)&#123;</span><br><span class="line">        postOrder(current.leftChild);</span><br><span class="line">        postOrder(current.rightChild);</span><br><span class="line">        System.out.print(current.data+&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简单题&quot;&gt;&lt;a href=&quot;#简单题&quot; class=&quot;headerlink&quot; title=&quot;简单题&quot;&gt;&lt;/a&gt;简单题&lt;/h2&gt;&lt;h3 id=&quot;100-相同的树&quot;&gt;&lt;a href=&quot;#100-相同的树&quot; class=&quot;headerlink&quot; title=&quot;100. 
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-数组</title>
    <link href="http://yoursite.com/2018/09/27/leetcode%E5%88%B7%E9%A2%98-%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/09/27/leetcode刷题-数组/</id>
    <published>2018-09-27T12:20:24.000Z</published>
    <updated>2018-09-27T12:22:58.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h2><h3 id="1-给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。"><a href="#1-给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。" class="headerlink" title="1.给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。"></a>1.给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</h3><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。<br>给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0,1]。</p><h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">       for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">        for(int j=i+1;j&lt;nums.length;j++)&#123;</span><br><span class="line">            if(nums[i]+nums[j] == target)&#123;</span><br><span class="line">                return new int[] &#123;i,j&#125;;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      throw new IllegalArgumentException(&quot;No two sum solution&quot;);  </span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两遍哈希表"><a href="#两遍哈希表" class="headerlink" title="两遍哈希表"></a>两遍哈希表</h4><p>在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]target−nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i]nums[i] 本身！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">       Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">       for(int i=0;i&lt; nums.length;i++)&#123;</span><br><span class="line">           map.put(nums[i],i);</span><br><span class="line">       &#125;</span><br><span class="line">       for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">          int complement = target - nums[i];</span><br><span class="line">           if(map.containsKey(complement) &amp;&amp; map.get(complement)!=i)&#123;</span><br><span class="line">              return new int[]&#123; i,map.get(complement) &#125;; </span><br><span class="line">           &#125;</span><br><span class="line">               </span><br><span class="line">       &#125;</span><br><span class="line">           </span><br><span class="line">     throw new IllegalArgumentException(&quot;No two sum solution&quot;);  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="一遍哈希表"><a href="#一遍哈希表" class="headerlink" title="一遍哈希表"></a>一遍哈希表</h4><p> 在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> class Solution &#123;</span><br><span class="line">   public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">       Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">       for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">          int complement = target - nums[i];</span><br><span class="line">           if(map.containsKey(complement))&#123;</span><br><span class="line">              return new int[]&#123; map.get(complement) ,i&#125;; </span><br><span class="line">           &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">       &#125;</span><br><span class="line">           </span><br><span class="line">     throw new IllegalArgumentException(&quot;No two sum solution&quot;);  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简单题&quot;&gt;&lt;a href=&quot;#简单题&quot; class=&quot;headerlink&quot; title=&quot;简单题&quot;&gt;&lt;/a&gt;简单题&lt;/h2&gt;&lt;h3 id=&quot;1-给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。&quot;&gt;&lt;a href=&quot;#1-给定一个整数数组和一个目标值，
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-链表</title>
    <link href="http://yoursite.com/2018/09/27/leetcode%E5%88%B7%E9%A2%98-ListNode/"/>
    <id>http://yoursite.com/2018/09/27/leetcode刷题-ListNode/</id>
    <published>2018-09-27T08:19:30.000Z</published>
    <updated>2018-10-03T01:45:11.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h2><h3 id="21-将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。"><a href="#21-将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。" class="headerlink" title="21.将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。"></a>21.将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</h3><p>eg:输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p>思路：每次都取两个中较小的一个，直到其中一个遍历到链表结尾结束遍历。如果这个时候还是剩下的元素，肯定比之前的元素都大，直接添加到链表结尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        if(l1 == null)</span><br><span class="line">        &#123;</span><br><span class="line">            return l2;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l2 ==null)</span><br><span class="line">        &#123;</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode merged =null;</span><br><span class="line">        ListNode head =null;</span><br><span class="line">        while(l1!=null &amp;&amp;l2!=null)&#123;</span><br><span class="line">            if(head ==null)&#123;</span><br><span class="line">                if(l1.val &lt;l2.val)&#123;</span><br><span class="line">                    merged =l1;</span><br><span class="line">                    l1=l1.next;</span><br><span class="line">                    </span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    merged =l2;</span><br><span class="line">                    l2=l2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                head =merged;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l1.val&lt;l2.val)&#123;</span><br><span class="line">                merged.next =l1;</span><br><span class="line">                l1 =l1.next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                merged.next =l2;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            merged =merged.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(l1 !=null)&#123;</span><br><span class="line">            merged.next =l1;</span><br><span class="line">            l1=l1.next;</span><br><span class="line">            merged=merged.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(l2 !=null)&#123;</span><br><span class="line">            merged.next =l2;</span><br><span class="line">            l2=l2.next;</span><br><span class="line">            merged=merged.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h3><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2</p><p>示例 2:</p><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p><p>解题思路：如果是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        ListNode current =head;</span><br><span class="line">        while(current !=null&amp;&amp;current.next !=null )&#123;</span><br><span class="line">            if(current.val==current.next.val)&#123;</span><br><span class="line">                current.next=current.next.next;&#125;</span><br><span class="line">            </span><br><span class="line">                else&#123;</span><br><span class="line">                    current=current.next;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">           return head;    </span><br><span class="line">        &#125;</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h3><p>给定一个链表，判断链表中是否有环。</p><h3 id="hash法"><a href="#hash法" class="headerlink" title="hash法"></a>hash法</h3><p>我们遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。如果当前结点为空结点 null（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。如果当前结点的引用已经存在于哈希表中，那么返回 true（即该链表为环形链表）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">    Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;();</span><br><span class="line">    while (head != null) &#123;</span><br><span class="line">        if (nodesSeen.contains(head)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            nodesSeen.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>通过使用具有不同速度的快、慢两个指针遍历链表，空间复杂度可以被降低至O(1)O(1)。慢指针每次移动一步，而快指针每次移动两步。</p><p>如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//查询是否有环（双向链表）</span><br><span class="line">public boolean hasCycle1(ListNode head) &#123;</span><br><span class="line">    if (head == null || head.next == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    while (slow != fast) &#123;</span><br><span class="line">        if (fast == null || fast.next == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h3><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>A:          a1 → a2<br>                   ↘<br>                     c1 → c2 → c3<br>                   ↗<br>B:     b1 → b2 → b3</p><p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p><p>解题思路：如果A和B是两个长度不同的链表，他们相交前的长度一定是不同的，计算链表长度差额n，让长的链表指针先开始移动n，两个指针再一起移动，指针相遇时就是链表结点的相交处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        int lengthA=calcListLength(headA);</span><br><span class="line">        int lengthB=calcListLength(headB);</span><br><span class="line">        int lenc=lengthA-lengthB;</span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;Math.abs(lenc);i++)&#123;</span><br><span class="line">            if(lenc&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                headA=headA.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                headB=headB.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while( headA !=null &amp;&amp; headB !=null)&#123;</span><br><span class="line">            if(headA == headB)&#123;</span><br><span class="line">                return headA;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            headA=headA.next;</span><br><span class="line">            headB=headB.next;</span><br><span class="line">    </span><br><span class="line">    &#125;   </span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int calcListLength(ListNode Node)&#123;</span><br><span class="line">        ListNode head=Node;</span><br><span class="line">        int i=0;</span><br><span class="line">        while(head !=null)&#123;</span><br><span class="line">            head=head.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h3><p>反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123; //先考虑链表是否为空</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head.next;</span><br><span class="line">        p1.next = null;</span><br><span class="line">        while (p2 != null) &#123;</span><br><span class="line">            ListNode temp = p2.next;</span><br><span class="line">            //设置一个tmp指针指向后续</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            //p2指针反转</span><br><span class="line">            p1 = p2;</span><br><span class="line">            //p1指针向前进</span><br><span class="line">            p2 = temp;  </span><br><span class="line">            //p2指针向前进</span><br><span class="line">        &#125;</span><br><span class="line">        return p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><p>解题思路：<br>假设1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null<br>已经变成1-&gt;2&lt;-3&lt;-4&lt;-5&lt;-null</p><p>2是<code>head.next</code></p><p>2的后继是<code>head.next.next</code></p><p>我们希望2的后继指向head所以是head=head.next.next</p><p>再去除1-&gt;2的环<code>head.next=null</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode subListHead = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = null;</span><br><span class="line">        return subListHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中等题"><a href="#中等题" class="headerlink" title="中等题"></a>中等题</h2><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h3><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p><p>输出：7 -&gt; 0 -&gt; 8</p><p>原因：342 + 465 = 807</p><h4 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">               ListNode dummyHead = new ListNode(0);</span><br><span class="line">               ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">               int carry = 0;</span><br><span class="line">               while (p != null || q != null) &#123;</span><br><span class="line">                   int x = (p != null) ? p.val : 0;</span><br><span class="line">                   int y = (q != null) ? q.val : 0;</span><br><span class="line">                   int sum = carry + x + y;</span><br><span class="line">                   carry = sum / 10;</span><br><span class="line">                   curr.next = new ListNode(sum % 10);</span><br><span class="line">                   curr = curr.next;</span><br><span class="line">                   if (p != null) p = p.next;</span><br><span class="line">                   if (q != null) q = q.next;</span><br><span class="line">               &#125;</span><br><span class="line">               if (carry &gt; 0) &#123;</span><br><span class="line">                   curr.next = new ListNode(carry);</span><br><span class="line">               &#125;</span><br><span class="line">               return dummyHead.next;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><h4 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"> public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">    if (l1 == null || l2 == null) &#123;</span><br><span class="line">        return l1 == null ? l2 : l1;</span><br><span class="line">    &#125;</span><br><span class="line">    int value = l1.val + l2.val;</span><br><span class="line">    ListNode result = new ListNode(value % 10);</span><br><span class="line">    //节点相加</span><br><span class="line">    result.next = addTwoNumbers(l1.next, l2.next);</span><br><span class="line">    //节点相加的结果和余数相加.</span><br><span class="line">    if (value &gt;= 10) &#123;</span><br><span class="line">        result.next = addTwoNumbers(new ListNode(value / 10),</span><br><span class="line">                      result.next);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h2><p>ListNode的类结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode</span><br><span class="line">&#123;</span><br><span class="line">    int val;//定义val变量值，存储节点值</span><br><span class="line">    ListNode next;//定义next指针，指向下一个节点，维持节点连接</span><br><span class="line">    </span><br><span class="line">    public ListNode(int x)&#123;</span><br><span class="line">        val=x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>注意注意val只代表当前指针的值，比如p-&gt;val表示p指针的指向的值；而p-&gt;next表示链表下一个节点，也是一个指针。</li><li>构造函数包含两个参数 _value 和 _next ，分别用来给节点赋值和指定下一节点</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简单题&quot;&gt;&lt;a href=&quot;#简单题&quot; class=&quot;headerlink&quot; title=&quot;简单题&quot;&gt;&lt;/a&gt;简单题&lt;/h2&gt;&lt;h3 id=&quot;21-将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Quick Start</title>
    <link href="http://yoursite.com/2018/09/27/hexo-Quick-start/"/>
    <id>http://yoursite.com/2018/09/27/hexo-Quick-start/</id>
    <published>2018-09-27T07:17:48.000Z</published>
    <updated>2018-10-07T06:35:22.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1. 安装hexo"></a>1. 安装hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo</span><br></pre></td></tr></table></figure><p>目录结构</p><ul><li>node_modules：是依赖包</li><li>public：存放的是生成的页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：用命令创建的各种文章</li><li>themes：主题</li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul><h2 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">hexo install</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>此时打开<a href="http://localhost:4000可以看到静态页" target="_blank" rel="noopener">http://localhost:4000可以看到静态页</a></p><h2 id="3-关联github"><a href="#3-关联github" class="headerlink" title="3.  关联github"></a>3.  关联github</h2><h4 id="gitbash连接"><a href="#gitbash连接" class="headerlink" title="gitbash连接"></a>gitbash连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱&quot;</span><br><span class="line">ssh-keygen -t rsa -C&quot;邮箱&quot;</span><br></pre></td></tr></table></figure><p>找到ssh key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure></p><p>将这段配置到github上后，检查一下是否配置成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>创建项目名为：用户名.github.io<br>在/blog下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/用户名/用户名.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>退出保存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><p>hexo d时提示ERROR Deployer not found:git</p><p>解决方法：<br>npm install –save hexo-deployer-git</p><h2 id="4-配置主题"><a href="#4-配置主题" class="headerlink" title="4. 配置主题"></a>4. 配置主题</h2><p>这边使用了yilia</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><p>修改hexo根目录下的 _config.yml<code>theme: yilia</code></p></li><li><p>配置yilia文件下的_config.yml</p></li></ul><p>配置头像时出现了头像不能展示的问题</p><p>解决方法：</p><ul><li><p>layout/_partial/left-col.ejs将第六行修改成如下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;&lt;%=theme.root%&gt;&lt;%=theme.avatar%&gt;&quot; class=&quot;js-avatar&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>将头像文件放在theme/source/img目录下，修改yilia的配置文件<br><code>avatar: img/myicon.jpg</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-安装hexo&quot;&gt;&lt;a href=&quot;#1-安装hexo&quot; class=&quot;headerlink&quot; title=&quot;1. 安装hexo&quot;&gt;&lt;/a&gt;1. 安装hexo&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/09/27/hello-world/"/>
    <id>http://yoursite.com/2018/09/27/hello-world/</id>
    <published>2018-09-27T02:53:18.075Z</published>
    <updated>2018-09-27T02:53:18.075Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
